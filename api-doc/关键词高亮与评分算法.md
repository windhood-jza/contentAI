# 关键词高亮与评分算法说明

## 关键词高亮实现方案

新闻搜索服务提供了关键词高亮功能，能够在搜索结果中突出显示匹配的关键词，提升用户体验和阅读效率。

### 高亮处理流程

1. **关键词分析**：分析用户输入的搜索关键词，提取需要高亮的词汇
2. **内容处理**：对搜索结果文本进行扫描，定位匹配关键词的位置
3. **标记插入**：在匹配位置前后插入HTML标记，用于实现高亮效果
4. **结果整合**：将带有高亮标记的内容返回给前端展示

### 具体实现

#### 后端高亮处理代码

```java
/**
 * 处理内容中的关键词高亮
 * @param content 原始内容
 * @param keywords 关键词列表
 * @return 带有高亮标记的内容
 */
private String highlightKeywords(String content, List<String> keywords) {
    if (content == null || content.isEmpty() || keywords == null || keywords.isEmpty()) {
        return content;
    }
    
    // 创建一个Pattern对象，用于匹配所有关键词（忽略大小写）
    StringBuilder patternBuilder = new StringBuilder();
    for (int i = 0; i < keywords.size(); i++) {
        if (i > 0) {
            patternBuilder.append("|");
        }
        patternBuilder.append("(").append(Pattern.quote(keywords.get(i))).append(")");
    }
    
    Pattern pattern = Pattern.compile(patternBuilder.toString(), Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(content);
    
    // 使用StringBuffer进行高效替换
    StringBuffer sb = new StringBuffer();
    while (matcher.find()) {
        String matchedText = matcher.group();
        // 替换为带有高亮标记的文本
        matcher.appendReplacement(sb, "<em>" + matchedText + "</em>");
    }
    matcher.appendTail(sb);
    
    return sb.toString();
}
```

#### 前端显示效果

前端页面通过CSS样式控制高亮显示效果：

```css
/* 关键词高亮样式 */
.search-result em {
    background-color: #ffff00;
    font-style: normal;
    font-weight: bold;
    padding: 0 2px;
}
```

### 高亮算法优化

1. **性能优化**：
   - 使用正则表达式一次性匹配所有关键词，减少多次遍历文本的开销
   - 使用 `StringBuffer` 而非 `String` 进行拼接，避免频繁创建字符串对象
   - 对于超长内容，可以只处理包含关键词的上下文片段，减少处理量

2. **准确性优化**：
   - 支持中英文混合关键词的精确匹配
   - 处理特殊字符和HTML实体，避免高亮标记破坏原有HTML结构
   - 对关键词前后的标点符号和空白进行智能处理

3. **用户体验优化**：
   - 限制每个关键词的高亮次数，避免过度高亮影响阅读
   - 对超长段落中的关键词高亮区域进行智能截取，形成摘要
   - 支持不同关键词使用不同高亮颜色，提高区分度

## 搜索结果评分算法

搜索结果评分是衡量搜索结果与用户查询相关性的重要指标，用于对结果进行排序，将最相关的结果优先展示给用户。

### 评分因素

1. **关键词匹配度**：
   - 关键词在文档中出现的频率
   - 关键词在标题中的出现权重高于正文
   - 精确匹配的权重高于部分匹配
   - 多个关键词全部匹配的权重高于部分关键词匹配

2. **位置权重**：
   - 关键词出现在文档开头的权重高于文档末尾
   - 关键词在标题中出现的权重最高
   - 关键词在段落首句出现的权重高于段落末句

3. **时间因素**：
   - 较新的文档获得更高的时间评分
   - 根据文档的发布时间计算时间衰减因子

4. **文档质量**：
   - 文档长度适中的文章评分较高
   - 过短或过长的文档适当降低评分

### 评分公式

基本评分计算公式如下：

```
最终评分 = 匹配度评分 * 0.65 + 位置评分 * 0.2 + 时间评分 * 0.1 + 质量评分 * 0.05
```

具体实现：

```java
/**
 * 计算搜索结果的评分
 * @param result 搜索结果
 * @param keywords 关键词列表
 * @return 计算得到的评分(0-100)
 */
private double calculateScore(SearchResult result, List<String> keywords) {
    // 基础数据提取
    String title = result.getTitle().toUpperCase();
    String content = result.getContent().toUpperCase();
    Date createTime = result.getCreateTime();
    
    // 1. 关键词匹配度评分 (0-65分)
    double matchScore = 0;
    int titleMatches = 0;
    int contentMatches = 0;
    
    for (String keyword : keywords) {
        String upperKeyword = keyword.toUpperCase();
        
        // 标题匹配计数
        int titleCount = countOccurrences(title, upperKeyword);
        titleMatches += titleCount;
        
        // 内容匹配计数
        int contentCount = countOccurrences(content, upperKeyword);
        contentMatches += contentCount;
    }
    
    // 计算匹配度评分
    double titleMatchScore = Math.min(titleMatches * 15, 40); // 标题匹配最高40分
    double contentMatchScore = Math.min(contentMatches * 0.5, 25); // 内容匹配最高25分
    matchScore = titleMatchScore + contentMatchScore;
    
    // 2. 位置评分 (0-20分)
    double positionScore = 0;
    // 检查是否有关键词出现在标题或内容前20%的位置
    for (String keyword : keywords) {
        String upperKeyword = keyword.toUpperCase();
        
        // 标题中首次出现的位置
        int titlePos = title.indexOf(upperKeyword);
        if (titlePos >= 0) {
            positionScore += 10 * (1 - titlePos / (double)title.length());
        }
        
        // 内容中首次出现的位置
        int contentPos = content.indexOf(upperKeyword);
        if (contentPos >= 0 && contentPos < content.length() * 0.2) {
            positionScore += 10 * (1 - contentPos / (content.length() * 0.2));
        }
    }
    positionScore = Math.min(positionScore, 20);
    
    // 3. 时间评分 (0-10分)
    double timeScore = 0;
    if (createTime != null) {
        // 计算文档年龄（以天为单位）
        long ageInDays = (System.currentTimeMillis() - createTime.getTime()) / (1000 * 60 * 60 * 24);
        // 时间衰减因子: 1年以内的文档评分较高
        timeScore = 10 * Math.exp(-ageInDays / 365.0);
    }
    
    // 4. 文档质量评分 (0-5分)
    double qualityScore = 0;
    int contentLength = content.length();
    // 理想文档长度在1000-5000字符之间
    if (contentLength >= 1000 && contentLength <= 5000) {
        qualityScore = 5;
    } else if (contentLength > 5000) {
        qualityScore = 5 * (1 - Math.min((contentLength - 5000) / 10000.0, 0.8));
    } else if (contentLength < 1000) {
        qualityScore = 5 * (contentLength / 1000.0);
    }
    
    // 计算最终评分
    double finalScore = matchScore * 0.65 + positionScore * 0.2 + timeScore * 0.1 + qualityScore * 0.05;
    
    return Math.min(finalScore, 100);
}

/**
 * 计算一个子串在主串中出现的次数
 */
private int countOccurrences(String text, String pattern) {
    int count = 0;
    int index = 0;
    while ((index = text.indexOf(pattern, index)) != -1) {
        count++;
        index += pattern.length();
    }
    return count;
}
```

### 评分算法优化方向

1. **用户行为反馈**：
   - 记录用户点击行为，通过点击率提升相关文档的评分
   - 收集用户停留时间数据，访问时间长的文档提升评分

2. **语义理解增强**：
   - 引入同义词扩展，对文档中包含查询关键词同义词的内容给予适当评分
   - 使用自然语言处理技术理解查询意图，优化匹配算法

3. **个性化推荐**：
   - 基于用户历史搜索行为，调整评分算法权重
   - 根据用户画像特征，针对不同用户提供定制化的评分结果

## 实际应用与效果

### 示例场景

假设用户搜索关键词 "经济政策"，系统会：

1. 在搜索结果中，将所有 "经济" 和 "政策" 出现的地方用 `<em>` 标签标记
2. 对所有匹配的文档进行评分计算
3. 按照评分从高到低排序返回结果
4. 在标题和内容中包含这两个词、且两个词距离较近的文档获得更高评分
5. 近期发布的文档在评分相近的情况下会排在更前面

### 性能与资源消耗

- 高亮处理和评分计算主要在后端服务器进行，对客户端无额外负担
- 单次搜索请求的处理时间控制在100ms以内，保证响应速度
- 对于大型数据集，评分算法采用部分预计算和缓存策略，降低实时计算负担

### 用户体验提升

通过关键词高亮和精准的评分排序，系统能够：

1. 帮助用户快速定位感兴趣的内容
2. 减少用户阅读无关内容的时间
3. 提高搜索结果的准确性和相关性
4. 为用户提供直观的关键词匹配反馈 